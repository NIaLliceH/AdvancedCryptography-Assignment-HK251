import requests
import time
from functools import reduce
import urllib3

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

USER_ID = "group-1"
SERVER_URL = "https://crypto-assignment.dangduongminhnhat2003.workers.dev"
USE_PROXY = True
PROXY_URL = "http://127.0.0.1:8080"
PROXIES = {
    "http": PROXY_URL,
    "https": PROXY_URL,
} if USE_PROXY else None

F_p = [
    13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 
    53, 59, 61, 67, 71, 73, 79, 83, 89, 97,
    101, 103, 107, 109, 113, 127, 131, 137, 139, 149,
    151, 157, 163, 167, 173, 179, 181, 191, 193, 197,
    199, 211, 223, 227, 229, 233, 239, 241, 251, 257
]

def inverse_mod(k, p):
    return pow(k, -1, p)

def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def point_add(p1, p2, p, a):
    if p1 is None: return p2
    if p2 is None: return p1
    x1, y1 = p1
    x2, y2 = p2
    if x1 == x2 and y1 != y2: return None
    if x1 == x2:
        if y1 == 0: return None
        m = (3*x1*x1 + a) * inverse_mod(2*y1, p)
    else:
        m = (y2 - y1) * inverse_mod(x2 - x1, p)
    m %= p
    x3 = (m*m - x1 - x2) % p
    y3 = (m*(x1 - x3) - y1) % p
    return (x3, y3)

def find_cyclic_group_with_prime_order(F_p, used_orders):
    for a in range(1, F_p):
        for b in range(1, F_p):
            if (4*a**3 + 27*b**2) % F_p == 0: # singularity check
                continue
            
            Gx, Gy = None, None
            for x in range(F_p):
                rhs = (x**3 + a*x + b) % F_p
                for y in range(1, F_p):
                    if (y*y) % F_p == rhs:
                        Gx, Gy = x, y # pick first point found to be G
                        break
            
            if Gx is None: continue # no point found
            
            # find order of cyclic group generated by G: 0, G, 2G, ..., (n-1)G
            current = (Gx, Gy)
            order = 1
            
            while True:
                current = point_add(current, (Gx, Gy), F_p, a)
                order += 1
                if current is None: # infinity point reached
                    break
            
            if is_prime(order) and order not in used_orders:
                return a, b, Gx, Gy, order
                
    return None

def extended_gcd(a, b):
    if a == 0: return b, 0, 1
    gcd, x1, y1 = extended_gcd(b % a, a)
    x = y1 - (b // a) * x1
    y = x1
    return gcd, x, y

def solve_crt(remainders, moduli):
    total_product = reduce(lambda x, y: x * y, moduli)
    result = 0
    for a_i, n_i in zip(remainders, moduli):
        N_i = total_product // n_i
        _, y_i, _ = extended_gcd(N_i, n_i)
        result += a_i * y_i * N_i
    return result % total_product

def small_cyclic_group_attack(p, a, b, Gx, Gy, order):
    payload = {
        "algorithm": "ecdh",
        "curveParameters": {
            "p": str(p), "a": str(a), "b": str(b),
            "Gx": str(Gx), "Gy": str(Gy), "order": str(order)
        }
    }
    try:
        resp = requests.post(
            f"{SERVER_URL}/session/create?userId={USER_ID}",
            json=payload, headers={"Content-Type": "application/json", "x-user-id": USER_ID},
            proxies=PROXIES, verify=False,
            timeout=5
        )
        
        data = resp.json()
        if not data.get("success"):
            return None
        
        srv_pub = data["serverPublicKey"]
        Px, Py = int(srv_pub["x"]), int(srv_pub["y"])
        
        target = (Px, Py)
        current = (Gx, Gy)

        for k in range(1, order):
            if current == target:
                return k
            current = point_add(current, (Gx, Gy), p, a)
        return None
    except:
        return None

def exploit():
    remainders = []
    orders = []
    
    M = 1 # M = p_1 * p_2 * ... * p_k
    
    for p in F_p:
        if M.bit_length() >= 192:
            print("\n[+] Collected enough modulo equations for 192-bit key recovery.")
            break
            
        print(f"[*] Searching on F_{p}: ", end="")
        
        params = find_cyclic_group_with_prime_order(p, orders)
        
        if not params:
            print("No suitable cyclic group found. Skipping.")
            continue
            
        a, b, Gx, Gy, order = params
        print(f"Order = {order}, a={a}, b={b}, G=({Gx},{Gy}) -> ", end="")
        
        k_mod = small_cyclic_group_attack(p, a, b, Gx, Gy, order)
        time.sleep(1) # rate limit
        
        if k_mod is not None:
            print(f"[OK] k = {k_mod} (mod {order})")
            remainders.append(k_mod)
            orders.append(order)
            M *= order
        else:
            print("[FAIL]")

    if M.bit_length() < 192:
        print("[!] Not enough 192 bits! Need to add more F_p.")
        return

    print(f"[*] Number of equations: {len(orders)}")
    print(f"[*] Total bit coverage: {M.bit_length()} bits")

    secret_key = solve_crt(remainders, orders)
    print(f"\n[+] RECOVERED PRIVATE KEY: {hex(secret_key)}")

if __name__ == "__main__":
    exploit()